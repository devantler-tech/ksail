name: Cache Containerd Images
description: Cache containerd images from inside Kubernetes clusters to avoid rate limiting when pulling deployment images
author: Devantler Tech Platform Team

inputs:
  cluster-name:
    description: Name of the cluster to cache images from
    required: true
  distribution:
    description: Kubernetes distribution (Vanilla, K3s, Talos)
    required: true
  provider:
    description: Infrastructure provider (Docker, Hetzner)
    required: true
    default: "Docker"
  operation:
    description: Operation to perform (restore, save)
    required: true

outputs:
  cache-hit:
    description: Whether the cache was hit ('true' or 'false')
    value: ${{ steps.restore-cache.outputs.cache-hit }}

runs:
  using: composite
  steps:
    - name: üîë Generate cache key
      id: cache-key
      shell: bash
      env:
        DISTRIBUTION: ${{ inputs.distribution }}
      run: |
        # Generate cache key based on distribution
        # This caches containerd images from deployment manifests (cert-manager, flux, argocd, etc.)
        DIST_LOWER=$(echo "$DISTRIBUTION" | tr '[:upper:]' '[:lower:]')
        CACHE_KEY="containerd-images-${DIST_LOWER}-v1"

        echo "key=$CACHE_KEY" >> "$GITHUB_OUTPUT"
        echo "Generated cache key: $CACHE_KEY"

    - name: ‚ôªÔ∏è Restore cached containerd images
      if: inputs.operation == 'restore' && inputs.provider == 'Docker'
      id: restore-cache
      uses: actions/cache/restore@9255dc7a253b0ccc959486e2bca901246202afeb # v5.0.1
      with:
        path: /tmp/containerd-cache
        key: ${{ steps.cache-key.outputs.key }}

    - name: üì¶ Load cached images into cluster
      if: inputs.operation == 'restore' && inputs.provider == 'Docker' && steps.restore-cache.outputs.cache-hit == 'true'
      shell: bash
      env:
        CLUSTER_NAME: ${{ inputs.cluster-name }}
        DISTRIBUTION: ${{ inputs.distribution }}
      run: |
        echo "Loading cached containerd images into cluster..."

        # Function to get container name based on distribution
        get_container_name() {
          local dist_lower
          dist_lower=$(echo "$DISTRIBUTION" | tr '[:upper:]' '[:lower:]')

          local container_name=""
          local max_retries=5
          local sleep_seconds=2

          # Find the first control-plane/server container for the cluster, with retries
          for i in $(seq 1 "$max_retries"); do
            case "$dist_lower" in
              vanilla)
                # Kind uses pattern: <cluster-name>-control-plane
                container_name=$(docker ps -a --filter "name=${CLUSTER_NAME}-control-plane" --format "{{.Names}}" | head -1)
                ;;
              k3s)
                # K3d uses pattern: k3d-<cluster-name>-server-*
                container_name=$(docker ps -a --filter "name=k3d-${CLUSTER_NAME}-server" --format "{{.Names}}" | head -1)
                ;;
              talos)
                # Talos uses labels, find by label
                container_name=$(docker ps -a --filter "label=talos.owned=true" --filter "label=talos.cluster.name=${CLUSTER_NAME}" --filter "label=talos.type=controlplane" --format "{{.Names}}" | head -1)
                ;;
              *)
                echo "Unknown distribution: $DISTRIBUTION" >&2
                return 1
                ;;
            esac

            if [ -n "$container_name" ]; then
              echo "$container_name"
              return 0
            fi

            if [ "$i" -lt "$max_retries" ]; then
              echo "Container for cluster ${CLUSTER_NAME} not found (attempt ${i}/${max_retries}). Retrying in ${sleep_seconds}s..." >&2
              sleep "$sleep_seconds"
            fi
          done

          echo "Warning: Could not find container for cluster ${CLUSTER_NAME} after ${max_retries} attempts." >&2
          return 1
        }

        # Get container name with retries
        CONTAINER_NAME=$(get_container_name)
        if [ -z "$CONTAINER_NAME" ]; then
          echo "Skipping cache restore - no container found."
          exit 0
        fi

        echo "Using container: $CONTAINER_NAME"

        # Check if cache exists and load images
        if [ -f "/tmp/containerd-cache/images.tar" ]; then
          echo "Importing cached images into containerd..."
          
          # Copy tar file into container
          docker cp /tmp/containerd-cache/images.tar "$CONTAINER_NAME":/tmp/images.tar
          
          # Import images into containerd
          # Use ctr (containerd CLI) to import images
          docker exec "$CONTAINER_NAME" sh -c "ctr -n k8s.io images import /tmp/images.tar || true"
          
          # Clean up
          docker exec "$CONTAINER_NAME" rm -f /tmp/images.tar
          
          echo "Cached images loaded successfully"
        else
          echo "No cached images found"
        fi

    - name: üíæ Export containerd images from cluster
      if: inputs.operation == 'save' && inputs.provider == 'Docker'
      shell: bash
      env:
        CLUSTER_NAME: ${{ inputs.cluster-name }}
        DISTRIBUTION: ${{ inputs.distribution }}
      run: |
        echo "Exporting containerd images from cluster..."

        # Function to get container name based on distribution
        get_container_name() {
          local dist_lower
          dist_lower=$(echo "$DISTRIBUTION" | tr '[:upper:]' '[:lower:]')

          local container_name=""
          local max_retries=5
          local sleep_seconds=2

          # Find the first control-plane/server container for the cluster, with retries
          for i in $(seq 1 "$max_retries"); do
            case "$dist_lower" in
              vanilla)
                # Kind uses pattern: <cluster-name>-control-plane
                container_name=$(docker ps -a --filter "name=${CLUSTER_NAME}-control-plane" --format "{{.Names}}" | head -1)
                ;;
              k3s)
                # K3d uses pattern: k3d-<cluster-name>-server-*
                container_name=$(docker ps -a --filter "name=k3d-${CLUSTER_NAME}-server" --format "{{.Names}}" | head -1)
                ;;
              talos)
                # Talos uses labels, find by label
                container_name=$(docker ps -a --filter "label=talos.owned=true" --filter "label=talos.cluster.name=${CLUSTER_NAME}" --filter "label=talos.type=controlplane" --format "{{.Names}}" | head -1)
                ;;
              *)
                echo "Unknown distribution: $DISTRIBUTION" >&2
                return 1
                ;;
            esac

            if [ -n "$container_name" ]; then
              echo "$container_name"
              return 0
            fi

            if [ "$i" -lt "$max_retries" ]; then
              echo "Container for cluster ${CLUSTER_NAME} not found (attempt ${i}/${max_retries}). Retrying in ${sleep_seconds}s..." >&2
              sleep "$sleep_seconds"
            fi
          done

          echo "Warning: Could not find container for cluster ${CLUSTER_NAME} after ${max_retries} attempts." >&2
          return 1
        }

        # Get container name with retries
        CONTAINER_NAME=$(get_container_name)
        if [ -z "$CONTAINER_NAME" ]; then
          echo "Skipping cache save - no container found."
          exit 0
        fi

        echo "Using container: $CONTAINER_NAME"

        # Create cache directory
        mkdir -p /tmp/containerd-cache

        # Export all images from containerd
        # Use ctr to export images
        echo "Listing images in containerd..."
        docker exec "$CONTAINER_NAME" ctr -n k8s.io images ls

        echo "Exporting images to tar archive..."
        docker exec "$CONTAINER_NAME" sh -c "ctr -n k8s.io images export /tmp/images.tar \$(ctr -n k8s.io images ls -q) || true"

        # Copy tar file from container to host if it was created
        if docker exec "$CONTAINER_NAME" test -f /tmp/images.tar; then
          docker cp "$CONTAINER_NAME":/tmp/images.tar /tmp/containerd-cache/images.tar

          # Clean up inside container
          docker exec "$CONTAINER_NAME" rm -f /tmp/images.tar

          echo "Images exported successfully"
          ls -lh /tmp/containerd-cache/
        else
          echo "Warning: /tmp/images.tar not found in container ${CONTAINER_NAME}. Skipping containerd image cache export."
        fi

    - name: üíæ Save containerd images to cache
      if: inputs.operation == 'save' && inputs.provider == 'Docker'
      uses: actions/cache/save@9255dc7a253b0ccc959486e2bca901246202afeb # v5.0.1
      with:
        path: /tmp/containerd-cache
        key: ${{ steps.cache-key.outputs.key }}
