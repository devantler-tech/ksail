name: Cache Containerd Images
description: Cache containerd images from inside Kubernetes clusters to avoid rate limiting when pulling deployment images
author: Devantler Tech Platform Team

inputs:
  cluster-name:
    description: Name of the cluster to cache images from
    required: true
  distribution:
    description: Kubernetes distribution (Vanilla, K3s, Talos)
    required: true
  provider:
    description: Infrastructure provider (Docker, Hetzner)
    required: true
    default: "Docker"
  operation:
    description: Operation to perform (restore, save)
    required: true

outputs:
  cache-hit:
    description: Whether the cache was hit ('true' or 'false')
    value: ${{ steps.restore-cache.outputs.cache-hit }}

runs:
  using: composite
  steps:
    - name: üîë Generate cache key
      id: cache-key
      shell: bash
      env:
        DISTRIBUTION: ${{ inputs.distribution }}
      run: |
        # Generate cache key based on distribution
        # This caches containerd images from deployment manifests (cert-manager, flux, argocd, etc.)
        DIST_LOWER=$(echo "$DISTRIBUTION" | tr '[:upper:]' '[:lower:]')
        CACHE_KEY="containerd-images-${DIST_LOWER}-v1"

        echo "key=$CACHE_KEY" >> "$GITHUB_OUTPUT"
        echo "Generated cache key: $CACHE_KEY"

    - name: ‚ôªÔ∏è Restore cached containerd images
      if: inputs.operation == 'restore' && inputs.provider == 'Docker'
      id: restore-cache
      uses: actions/cache/restore@9255dc7a253b0ccc959486e2bca901246202afeb # v5.0.1
      with:
        path: /tmp/containerd-cache
        key: ${{ steps.cache-key.outputs.key }}

    - name: üì¶ Load cached images into cluster
      if: inputs.operation == 'restore' && inputs.provider == 'Docker' && steps.restore-cache.outputs.cache-hit == 'true'
      shell: bash
      env:
        CLUSTER_NAME: ${{ inputs.cluster-name }}
        DISTRIBUTION: ${{ inputs.distribution }}
      run: |
        echo "Loading cached containerd images into cluster..."

        # Determine container name based on distribution
        DIST_LOWER=$(echo "$DISTRIBUTION" | tr '[:upper:]' '[:lower:]')

        # Find the first control-plane/server container for the cluster
        case "$DIST_LOWER" in
          vanilla)
            # Kind uses pattern: <cluster-name>-control-plane
            CONTAINER_NAME=$(docker ps -a --filter "name=${CLUSTER_NAME}-control-plane" --format "{{.Names}}" | head -1)
            ;;
          k3s)
            # K3d uses pattern: k3d-<cluster-name>-server-*
            CONTAINER_NAME=$(docker ps -a --filter "name=k3d-${CLUSTER_NAME}-server" --format "{{.Names}}" | head -1)
            ;;
          talos)
            # Talos uses labels, find by label
            CONTAINER_NAME=$(docker ps -a --filter "label=talos.owned=true" --filter "label=talos.cluster.name=${CLUSTER_NAME}" --filter "label=talos.type=controlplane" --format "{{.Names}}" | head -1)
            ;;
          *)
            echo "Unknown distribution: $DISTRIBUTION"
            exit 1
            ;;
        esac

        if [ -z "$CONTAINER_NAME" ]; then
          echo "Error: Could not find container for cluster ${CLUSTER_NAME}"
          exit 1
        fi

        echo "Using container: $CONTAINER_NAME"

        # Check if cache exists and load images
        if [ -f "/tmp/containerd-cache/images.tar" ]; then
          echo "Importing cached images into containerd..."
          
          # Copy tar file into container
          docker cp /tmp/containerd-cache/images.tar "$CONTAINER_NAME":/tmp/images.tar
          
          # Import images into containerd
          # Use ctr (containerd CLI) to import images
          docker exec "$CONTAINER_NAME" sh -c "ctr -n k8s.io images import /tmp/images.tar || true"
          
          # Clean up
          docker exec "$CONTAINER_NAME" rm -f /tmp/images.tar
          
          echo "Cached images loaded successfully"
        else
          echo "No cached images found"
        fi

    - name: üíæ Export containerd images from cluster
      if: inputs.operation == 'save' && inputs.provider == 'Docker'
      shell: bash
      env:
        CLUSTER_NAME: ${{ inputs.cluster-name }}
        DISTRIBUTION: ${{ inputs.distribution }}
      run: |
        echo "Exporting containerd images from cluster..."

        # Determine container name based on distribution
        DIST_LOWER=$(echo "$DISTRIBUTION" | tr '[:upper:]' '[:lower:]')

        # Find the first control-plane/server container for the cluster
        case "$DIST_LOWER" in
          vanilla)
            # Kind uses pattern: <cluster-name>-control-plane
            CONTAINER_NAME=$(docker ps -a --filter "name=${CLUSTER_NAME}-control-plane" --format "{{.Names}}" | head -1)
            ;;
          k3s)
            # K3d uses pattern: k3d-<cluster-name>-server-*
            CONTAINER_NAME=$(docker ps -a --filter "name=k3d-${CLUSTER_NAME}-server" --format "{{.Names}}" | head -1)
            ;;
          talos)
            # Talos uses labels, find by label
            CONTAINER_NAME=$(docker ps -a --filter "label=talos.owned=true" --filter "label=talos.cluster.name=${CLUSTER_NAME}" --filter "label=talos.type=controlplane" --format "{{.Names}}" | head -1)
            ;;
          *)
            echo "Unknown distribution: $DISTRIBUTION"
            exit 1
            ;;
        esac

        if [ -z "$CONTAINER_NAME" ]; then
          echo "Error: Could not find container for cluster ${CLUSTER_NAME}"
          exit 1
        fi

        echo "Using container: $CONTAINER_NAME"

        # Create cache directory
        mkdir -p /tmp/containerd-cache

        # Export all images from containerd
        # Use ctr to export images
        echo "Listing images in containerd..."
        docker exec "$CONTAINER_NAME" ctr -n k8s.io images ls

        echo "Exporting images to tar archive..."
        docker exec "$CONTAINER_NAME" sh -c "ctr -n k8s.io images export /tmp/images.tar \$(ctr -n k8s.io images ls -q) || true"

        # Copy tar file from container to host if it was created
        if docker exec "$CONTAINER_NAME" test -f /tmp/images.tar; then
          docker cp "$CONTAINER_NAME":/tmp/images.tar /tmp/containerd-cache/images.tar

          # Clean up inside container
          docker exec "$CONTAINER_NAME" rm -f /tmp/images.tar

          echo "Images exported successfully"
          ls -lh /tmp/containerd-cache/
        else
          echo "Warning: /tmp/images.tar not found in container ${CONTAINER_NAME}. Skipping containerd image cache export."
        fi

    - name: üíæ Save containerd images to cache
      if: inputs.operation == 'save' && inputs.provider == 'Docker'
      uses: actions/cache/save@9255dc7a253b0ccc959486e2bca901246202afeb # v5.0.1
      with:
        path: /tmp/containerd-cache
        key: ${{ steps.cache-key.outputs.key }}
