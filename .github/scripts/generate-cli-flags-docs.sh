#!/bin/bash

# Script to generate CLI flags documentation from KSail help output
# This script is used by the CI/CD pipeline to keep docs in sync
# Output: Astro Starlight MDX files in docs/src/content/docs/cli-flags/

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(cd "$SCRIPT_DIR/../.." && pwd)"
DOCS_DIR="$REPO_ROOT/docs/src/content/docs/cli-flags"

# Check for global ksail first, then fall back to local
if command -v ksail &>/dev/null; then
	KSAIL_BINARY="$(command -v ksail)"
else
	KSAIL_BINARY="$REPO_ROOT/ksail"
fi

echo "Generating CLI flags documentation from KSail help output..."
echo "Using ksail binary: $KSAIL_BINARY"

# Ensure KSail binary exists
if [ ! -f "$KSAIL_BINARY" ]; then
	echo "Error: KSail binary not found. Install globally or build locally with 'go build -o ksail'" >&2
	exit 1
fi

# Clean and recreate docs directory (but preserve index.mdx if it exists)
if [ -f "$DOCS_DIR/index.mdx" ]; then
	cp "$DOCS_DIR/index.mdx" /tmp/cli-flags-index.mdx.bak
fi
rm -rf "$DOCS_DIR"
mkdir -p "$DOCS_DIR"
if [ -f /tmp/cli-flags-index.mdx.bak ]; then
	mv /tmp/cli-flags-index.mdx.bak "$DOCS_DIR/index.mdx"
fi

# Helper function to create a documentation page (Starlight MDX format)
# Args: $1 = output file path, $2 = title, $3 = description, $4+ = command args
create_doc_page() {
	local output_file="$1"
	local title="$2"
	local description="$3"
	shift 3
	local cmd_args=("$@")

	mkdir -p "$(dirname "$output_file")"

	{
		echo "---"
		echo "title: \"$title\""
		echo "description: \"$description\""
		echo "---"
		echo ""
		echo "{/* This page is auto-generated by .github/scripts/generate-cli-flags-docs.sh */}"
		echo ""
		echo '```text'
		# Sanitize user-specific paths (e.g., /Users/username/... or /home/username/...) to use ~
		"$KSAIL_BINARY" "${cmd_args[@]}" --help 2>&1 | sed -E 's|"/Users/[^/]+/|"~/|g; s|"/home/[^/]+/|"~/|g'
		echo '```'
	} >"$output_file"
}

# Helper function to extract available commands from help output
# Returns: list of subcommand names, one per line
get_subcommands() {
	"$KSAIL_BINARY" "$@" --help 2>&1 |
		sed -n '/^Available Commands:/,/^Flags:/p' |
		grep -E '^  [a-z]' |
		awk '{print $1}' |
		grep -v '^help$' |
		grep -v '^completion$' || true
}

# Helper function to get command description from help output
get_command_description() {
	"$KSAIL_BINARY" "$@" --help 2>&1 | head -1
}

# Helper function to generate docs for a command and its subcommands
# Args: $1+ = command path components
generate_command_docs() {
	local cmd_parts=("$@")

	# Build paths and titles
	local cmd_path="${cmd_parts[*]}"
	local dir_path="${cmd_path// //}"
	local file_prefix="${cmd_path// /-}"
	local full_cmd_title="ksail ${cmd_path}"
	local description
	description=$(get_command_description "${cmd_parts[@]}")

	# Create the root page for this command
	echo "Generating ${full_cmd_title} documentation..."
	mkdir -p "$DOCS_DIR/$dir_path"
	create_doc_page \
		"$DOCS_DIR/$dir_path/${file_prefix}-root.mdx" \
		"$full_cmd_title" \
		"$description" \
		"${cmd_parts[@]}"

	# Get subcommands for this command
	local subcommands
	subcommands=$(get_subcommands "${cmd_parts[@]}")

	# Generate docs for each subcommand
	if [ -n "$subcommands" ]; then
		while IFS= read -r subcmd; do
			[ -z "$subcmd" ] && continue

			local subcmd_parts=("${cmd_parts[@]}" "$subcmd")
			local subcmd_path="${subcmd_parts[*]}"
			local subcmd_title="ksail ${subcmd_path}"
			local subcmd_file="${file_prefix}-${subcmd}.mdx"
			local subcmd_description
			subcmd_description=$(get_command_description "${subcmd_parts[@]}")

			# Check if this subcommand has further subcommands
			local has_subcommands
			has_subcommands=$(get_subcommands "${subcmd_parts[@]}")

			if [ -n "$has_subcommands" ]; then
				# This is a command group with subcommands - recurse
				generate_command_docs "${subcmd_parts[@]}"
			else
				# This is a leaf command - create the doc page
				create_doc_page \
					"$DOCS_DIR/$dir_path/${subcmd_file}" \
					"$subcmd_title" \
					"$subcmd_description" \
					"${subcmd_parts[@]}"
			fi
		done <<<"$subcommands"
	fi
}

# Get top-level commands
top_level_commands=$(get_subcommands)

# Generate docs for each top-level command and its subcommands
while IFS= read -r cmd; do
	[ -z "$cmd" ] && continue
	generate_command_docs "$cmd"
done <<<"$top_level_commands"

echo "CLI flags documentation generation completed successfully"
echo "Generated $(find "$DOCS_DIR" -name '*.mdx' | wc -l) documentation pages"
