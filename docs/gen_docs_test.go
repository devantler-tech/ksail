package docs_test

import (
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/devantler-tech/ksail/v5/pkg/apis/cluster/v1alpha1"
	"github.com/devantler-tech/ksail/v5/pkg/cli/cmd"
	"github.com/spf13/cobra"
)

// countCommands returns the number of non-helper leaf and group-root
// commands in the Cobra tree (matching the shell script's behaviour).
func countCommands(c *cobra.Command) int {
	var subs []*cobra.Command

	for _, sub := range c.Commands() {
		if sub.Name() == "help" || sub.Name() == "completion" {
			continue
		}

		subs = append(subs, sub)
	}

	if len(subs) == 0 {
		return 1 // leaf
	}

	count := 1 // group root page

	for _, sub := range subs {
		count += countCommands(sub)
	}

	return count
}

func TestCLIFlagsDocsExist(t *testing.T) {
	t.Parallel()

	dir := "src/content/docs/cli-flags"

	if _, err := os.Stat(dir); os.IsNotExist(err) {
		t.Skipf("CLI flags docs not generated yet (run go generate ./docs/...): %s", dir)
	}

	rootCmd := cmd.NewRootCmd("test", "", "")

	// We don't generate a page for the bare "ksail" root, so subtract 1.
	expected := countCommands(rootCmd) - 1

	var actual int

	err := filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		if !info.IsDir() && strings.HasSuffix(path, ".mdx") && !strings.HasSuffix(path, "index.mdx") {
			actual++
		}

		return nil
	})
	if err != nil {
		t.Fatalf("walking %s: %v", dir, err)
	}

	if actual != expected {
		t.Errorf("expected %d CLI flags pages, got %d", expected, actual)
	}
}

func TestCLIFlagsPagesHaveFrontmatter(t *testing.T) {
	t.Parallel()

	dir := "src/content/docs/cli-flags"

	if _, err := os.Stat(dir); os.IsNotExist(err) {
		t.Skipf("CLI flags docs not generated yet: %s", dir)
	}

	err := filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		if info.IsDir() || strings.HasSuffix(path, "index.mdx") || !strings.HasSuffix(path, ".mdx") {
			return nil
		}

		content, readErr := os.ReadFile(path)
		if readErr != nil {
			return readErr
		}

		text := string(content)
		if !strings.HasPrefix(text, "---\n") {
			t.Errorf("%s: missing frontmatter (should start with ---)", path)
		}

		if !strings.Contains(text, "title:") {
			t.Errorf("%s: missing title in frontmatter", path)
		}

		if !strings.Contains(text, "description:") {
			t.Errorf("%s: missing description in frontmatter", path)
		}

		return nil
	})
	if err != nil {
		t.Fatalf("walking %s: %v", dir, err)
	}
}

func TestIndexMDXPreserved(t *testing.T) {
	t.Parallel()

	indexPath := "src/content/docs/cli-flags/index.mdx"

	content, err := os.ReadFile(indexPath)
	if os.IsNotExist(err) {
		t.Skipf("index.mdx not present (run go generate ./docs/...)")
	}

	if err != nil {
		t.Fatalf("reading %s: %v", indexPath, err)
	}

	text := string(content)

	if !strings.Contains(text, "title: CLI Flags") {
		t.Error("index.mdx: missing expected title")
	}

	if !strings.Contains(text, "Command Groups") {
		t.Error("index.mdx: missing Command Groups section")
	}
}

func TestConfigReferenceExists(t *testing.T) {
	t.Parallel()

	path := "src/content/docs/configuration/declarative-configuration.mdx"

	if _, err := os.Stat(path); os.IsNotExist(err) {
		t.Skipf("config reference not generated yet (run go generate ./docs/...): %s", path)
	}

	content, err := os.ReadFile(path)
	if err != nil {
		t.Fatalf("reading %s: %v", path, err)
	}

	text := string(content)

	t.Run("has frontmatter", func(t *testing.T) {
		t.Parallel()

		if !strings.HasPrefix(text, "---\n") {
			t.Error("missing frontmatter")
		}
	})

	t.Run("has auto-gen tag", func(t *testing.T) {
		t.Parallel()

		if !strings.Contains(text, "auto-generated by go generate") {
			t.Error("missing auto-generation tag")
		}
	})

	t.Run("has configuration reference section", func(t *testing.T) {
		t.Parallel()

		if !strings.Contains(text, "## Configuration Reference") {
			t.Error("missing Configuration Reference section")
		}
	})

	t.Run("has enum values from types", func(t *testing.T) {
		t.Parallel()

		dist := v1alpha1.Distribution("")
		for _, v := range dist.ValidValues() {
			if !strings.Contains(text, "`"+v+"`") {
				t.Errorf("missing distribution value %q", v)
			}
		}

		cni := v1alpha1.CNI("")
		for _, v := range cni.ValidValues() {
			if !strings.Contains(text, "`"+v+"`") {
				t.Errorf("missing CNI value %q", v)
			}
		}
	})

	t.Run("has environment variable expansion section", func(t *testing.T) {
		t.Parallel()

		if !strings.Contains(text, "Environment Variable Expansion") {
			t.Error("missing Environment Variable Expansion section")
		}
	})

	t.Run("has schema support section", func(t *testing.T) {
		t.Parallel()

		if !strings.Contains(text, "Schema Support") {
			t.Error("missing Schema Support section")
		}
	})
}
