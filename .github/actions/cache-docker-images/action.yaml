name: Cache Containerd Images
description: Cache containerd images from inside Kubernetes clusters to avoid rate limiting when pulling deployment images
author: Devantler Tech Platform Team

inputs:
  cluster-name:
    description: Name of the cluster to cache images from
    required: true
  distribution:
    description: Kubernetes distribution (Vanilla, K3s, Talos)
    required: true
  operation:
    description: Operation to perform (restore, save)
    required: true

outputs:
  cache-hit:
    description: Whether the cache was hit ('true' or 'false')
    value: ${{ steps.restore-cache.outputs.cache-hit }}

runs:
  using: composite
  steps:
    - name: üîë Generate cache key
      id: cache-key
      shell: bash
      env:
        DISTRIBUTION: ${{ inputs.distribution }}
      run: |
        # Generate cache key based on distribution
        # This caches containerd images from deployment manifests (cert-manager, flux, argocd, etc.)
        DIST_LOWER=$(echo "$DISTRIBUTION" | tr '[:upper:]' '[:lower:]')
        CACHE_KEY="containerd-images-${DIST_LOWER}-v1"

        echo "key=$CACHE_KEY" >> "$GITHUB_OUTPUT"
        echo "Generated cache key: $CACHE_KEY"

    - name: ‚ôªÔ∏è Restore cached containerd images
      if: inputs.operation == 'restore'
      id: restore-cache
      uses: actions/cache/restore@9255dc7a253b0ccc959486e2bca901246202afeb # v5.0.1
      with:
        path: /tmp/containerd-cache
        key: ${{ steps.cache-key.outputs.key }}

    - name: üì¶ Load cached images into cluster
      if: inputs.operation == 'restore' && steps.restore-cache.outputs.cache-hit == 'true'
      shell: bash
      env:
        CLUSTER_NAME: ${{ inputs.cluster-name }}
        DISTRIBUTION: ${{ inputs.distribution }}
      run: |
        echo "Loading cached containerd images into cluster..."

        # Function to get container name based on distribution
        get_container_name() {
          local dist_lower
          dist_lower=$(echo "$DISTRIBUTION" | tr '[:upper:]' '[:lower:]')

          local container_name=""
          local max_retries=5
          local sleep_seconds=2

          # Find the first control-plane/server container for the cluster, with retries
          for i in $(seq 1 "$max_retries"); do
            case "$dist_lower" in
              vanilla)
                # Kind uses pattern: <cluster-name>-control-plane
                container_name=$(docker ps -a --filter "name=${CLUSTER_NAME}-control-plane" --format "{{.Names}}" | head -1)
                ;;
              k3s)
                # K3d uses pattern: k3d-<cluster-name>-server-N (excluding serverlb)
                # We need to specifically match server-N pattern and exclude serverlb
                container_name=$(docker ps -a --filter "name=k3d-${CLUSTER_NAME}-server-" --format "{{.Names}}" | grep -v "serverlb" | head -1)
                ;;
              talos)
                # Talos uses labels, find by label
                container_name=$(docker ps -a --filter "label=talos.owned=true" --filter "label=talos.cluster.name=${CLUSTER_NAME}" --filter "label=talos.type=controlplane" --format "{{.Names}}" | head -1)
                ;;
              *)
                echo "Unknown distribution: $DISTRIBUTION" >&2
                return 1
                ;;
            esac

            if [ -n "$container_name" ]; then
              echo "$container_name"
              return 0
            fi

            if [ "$i" -lt "$max_retries" ]; then
              echo "Container for cluster ${CLUSTER_NAME} not found (attempt ${i}/${max_retries}). Retrying in ${sleep_seconds}s..." >&2
              sleep "$sleep_seconds"
            fi
          done

          echo "Warning: Could not find container for cluster ${CLUSTER_NAME} after ${max_retries} attempts." >&2
          return 1
        }

        # Get container name with retries
        CONTAINER_NAME=$(get_container_name)
        if [ -z "$CONTAINER_NAME" ]; then
          echo "Skipping cache restore - no container found."
          exit 0
        fi

        echo "Using container: $CONTAINER_NAME"

        # Determine ctr command path based on distribution
        DIST_LOWER=$(echo "$DISTRIBUTION" | tr '[:upper:]' '[:lower:]')
        if [ "$DIST_LOWER" = "talos" ]; then
          CTR_CMD="/sbin/ctr"
        else
          CTR_CMD="ctr"
        fi

        echo "Using ctr command: $CTR_CMD"

        # Check if cache exists and load images
        if [ -f "/tmp/containerd-cache/images.tar" ]; then
          echo "Importing cached images into containerd..."
          
          # Copy tar file into container
          docker cp /tmp/containerd-cache/images.tar "$CONTAINER_NAME":/tmp/images.tar
          
          # Import images into containerd
          # Use ctr (containerd CLI) to import images
          docker exec "$CONTAINER_NAME" sh -c "$CTR_CMD -n k8s.io images import /tmp/images.tar || true"
          
          # Clean up
          docker exec "$CONTAINER_NAME" rm -f /tmp/images.tar
          
          echo "Cached images loaded successfully"
        else
          echo "No cached images found"
        fi

    - name: üíæ Export containerd images from cluster
      if: inputs.operation == 'save'
      shell: bash
      env:
        CLUSTER_NAME: ${{ inputs.cluster-name }}
        DISTRIBUTION: ${{ inputs.distribution }}
      run: |
        echo "Exporting containerd images from cluster..."

        # Function to get container name based on distribution
        get_container_name() {
          local dist_lower
          dist_lower=$(echo "$DISTRIBUTION" | tr '[:upper:]' '[:lower:]')

          local container_name=""
          local max_retries=5
          local sleep_seconds=2

          # Find the first control-plane/server container for the cluster, with retries
          for i in $(seq 1 "$max_retries"); do
            case "$dist_lower" in
              vanilla)
                # Kind uses pattern: <cluster-name>-control-plane
                container_name=$(docker ps -a --filter "name=${CLUSTER_NAME}-control-plane" --format "{{.Names}}" | head -1)
                ;;
              k3s)
                # K3d uses pattern: k3d-<cluster-name>-server-N (excluding serverlb)
                # We need to specifically match server-N pattern and exclude serverlb
                container_name=$(docker ps -a --filter "name=k3d-${CLUSTER_NAME}-server-" --format "{{.Names}}" | grep -v "serverlb" | head -1)
                ;;
              talos)
                # Talos uses labels, find by label
                container_name=$(docker ps -a --filter "label=talos.owned=true" --filter "label=talos.cluster.name=${CLUSTER_NAME}" --filter "label=talos.type=controlplane" --format "{{.Names}}" | head -1)
                ;;
              *)
                echo "Unknown distribution: $DISTRIBUTION" >&2
                return 1
                ;;
            esac

            if [ -n "$container_name" ]; then
              echo "$container_name"
              return 0
            fi

            if [ "$i" -lt "$max_retries" ]; then
              echo "Container for cluster ${CLUSTER_NAME} not found (attempt ${i}/${max_retries}). Retrying in ${sleep_seconds}s..." >&2
              sleep "$sleep_seconds"
            fi
          done

          echo "Warning: Could not find container for cluster ${CLUSTER_NAME} after ${max_retries} attempts." >&2
          return 1
        }

        # Get container name with retries
        CONTAINER_NAME=$(get_container_name)
        if [ -z "$CONTAINER_NAME" ]; then
          echo "Skipping cache save - no container found."
          exit 0
        fi

        echo "Using container: $CONTAINER_NAME"

        # Determine ctr command path based on distribution
        DIST_LOWER=$(echo "$DISTRIBUTION" | tr '[:upper:]' '[:lower:]')
        if [ "$DIST_LOWER" = "talos" ]; then
          CTR_CMD="/sbin/ctr"
        else
          CTR_CMD="ctr"
        fi

        echo "Using ctr command: $CTR_CMD"

        # Create cache directory
        mkdir -p /tmp/containerd-cache

        # Export all images from containerd
        # Use ctr to export images
        echo "Listing images in containerd..."
        docker exec "$CONTAINER_NAME" $CTR_CMD -n k8s.io images ls

        # Get list of images to export
        echo "Getting list of images to export..."
        IMAGE_LIST=$(docker exec "$CONTAINER_NAME" $CTR_CMD -n k8s.io images ls -q 2>/dev/null || true)

        if [ -z "$IMAGE_LIST" ]; then
          echo "No images found in containerd. Skipping cache save."
          exit 0
        fi

        echo "Exporting images to tar archive..."
        # Export images one by one to handle corrupted manifests gracefully
        # First, try to export all at once (faster if all images are healthy)
        echo "Attempting bulk export..."
        if docker exec "$CONTAINER_NAME" sh -c "$CTR_CMD -n k8s.io images export /tmp/images.tar \$($CTR_CMD -n k8s.io images ls -q)" 2>&1; then
          echo "Bulk export succeeded"
        else
          echo "Bulk export failed, falling back to individual image export..."
          # Remove any partial tar file
          docker exec "$CONTAINER_NAME" rm -f /tmp/images.tar
          
          # Export images one by one, skipping failures
          EXPORT_COUNT=0
          TAR_CREATED=false
          while IFS= read -r image; do
            if [ -n "$image" ]; then
              if [ "$TAR_CREATED" = "false" ]; then
                # First successful image: create new tar
                if docker exec "$CONTAINER_NAME" $CTR_CMD -n k8s.io images export /tmp/images.tar "$image" 2>/dev/null; then
                  echo "‚úì Exported: $image"
                  EXPORT_COUNT=$((EXPORT_COUNT + 1))
                  TAR_CREATED=true
                else
                  echo "‚úó Skipped (corrupted): $image"
                fi
              else
                # Subsequent images: export to temp and append
                if docker exec "$CONTAINER_NAME" $CTR_CMD -n k8s.io images export /tmp/image-temp.tar "$image" 2>/dev/null; then
                  # Append the temp tar to the main tar file
                  if docker exec "$CONTAINER_NAME" tar -Af /tmp/images.tar /tmp/image-temp.tar 2>/dev/null; then
                    docker exec "$CONTAINER_NAME" rm -f /tmp/image-temp.tar 2>/dev/null || true
                    echo "‚úì Exported: $image"
                    EXPORT_COUNT=$((EXPORT_COUNT + 1))
                  else
                    echo "‚úó Skipped (append failed): $image"
                    docker exec "$CONTAINER_NAME" rm -f /tmp/image-temp.tar 2>/dev/null || true
                  fi
                else
                  echo "‚úó Skipped (corrupted): $image"
                fi
              fi
            fi
          done <<< "$IMAGE_LIST"
          
          echo "Export summary: $EXPORT_COUNT images exported, TAR_CREATED=$TAR_CREATED"
          
          if [ "$TAR_CREATED" = "false" ]; then
            echo "Warning: No images could be exported (tar file was never created)"
            exit 0
          fi
          
          if [ $EXPORT_COUNT -gt 0 ]; then
            echo "Successfully exported $EXPORT_COUNT images"
          fi
        fi

        # Copy tar file from container to host if it was created
        echo "Checking if tar file exists in container..."
        if docker exec "$CONTAINER_NAME" test -f /tmp/images.tar; then
          # Check if the tar file has content
          TAR_SIZE=$(docker exec "$CONTAINER_NAME" stat -c%s /tmp/images.tar 2>/dev/null || echo "0")
          if [ "$TAR_SIZE" -gt 0 ]; then
            docker cp "$CONTAINER_NAME":/tmp/images.tar /tmp/containerd-cache/images.tar

            # Clean up inside container
            docker exec "$CONTAINER_NAME" rm -f /tmp/images.tar

            echo "Images exported successfully"
            ls -lh /tmp/containerd-cache/
          else
            echo "Warning: /tmp/images.tar is empty. Skipping containerd image cache export."
            docker exec "$CONTAINER_NAME" rm -f /tmp/images.tar
          fi
        else
          echo "Warning: /tmp/images.tar not found in container ${CONTAINER_NAME}. Skipping containerd image cache export."
        fi

    - name: üíæ Save containerd images to cache
      if: inputs.operation == 'save'
      uses: actions/cache/save@9255dc7a253b0ccc959486e2bca901246202afeb # v5.0.1
      with:
        path: /tmp/containerd-cache
        key: ${{ steps.cache-key.outputs.key }}
