# Contributing

This project accepts contributions in the form of [**bug reports**](https://github.com/devantler-tech/ksail/issues/new/choose), [**feature requests**](https://github.com/devantler-tech/ksail/issues/new/choose), and **pull requests** (see below). If you are looking to contribute code, please follow the guidelines outlined in this document.

## Getting Started

To get started with contributing to KSail, you'll need to set up your development environment, and understand the codebase, the CI setup and its requirements.

To understand the codebase it is recommended to read the [.github/copilot-instructions.md](.github/copilot-instructions.md) file, which provides an overview of the project structure and key components. You can also use GitHub Copilot to assist you in navigating the codebase and understanding its functionality.

### Code Documentation

For detailed package and API documentation, refer to the Go documentation at [pkg.go.dev/github.com/devantler-tech/ksail/v5](https://pkg.go.dev/github.com/devantler-tech/ksail/v5). This provides comprehensive documentation for all exported packages, types, functions, and methods.

### Prerequisites

**Runtime Requirements:**

- [Docker](https://www.docker.com/get-started/) — The only required external dependency for running KSail

**Development Requirements:**

Before you begin developing, ensure you have the following installed:

- [Go (v1.26.0+)](https://go.dev/doc/install)
- [mockery (v3.5+)](https://vektra.github.io/mockery/v3.5/installation/)
- [golangci-lint](https://golangci-lint.run/docs/welcome/install/)
- [mega-linter](https://megalinter.io/latest/mega-linter-runner/#installation)
- [Node.js (v22+)](https://nodejs.org/en/download/) — Required for building documentation (matches CI)

### Lint

KSail uses mega-linter with the go flavor, and uses a strict configuration to ensure code quality and consistency. You can run the linter with the following command:

```sh
# working-directory: ./
mega-linter-runner -f go
```

The same configuration is used in CI, so you can expect the same linting behavior in your local environment as in the CI pipeline.

MegaLinter also checks Markdown files. Markdown lint rules are configured in `.markdownlint.json` (some rules are relaxed to accommodate Astro/Starlight front matter and documentation formatting).

### Build

```sh
# working-directory: ./
# Build the ksail binary (development build)
go build -o ksail

# Or: compile all packages (no binary output)
go build ./...

# For optimized builds (uses the same -ldflags as release builds):
go build -ldflags="-s -w" -o ksail-optimized
```

> **Note:** Release builds use `-ldflags="-s -w"` to strip debug symbols, which can significantly reduce binary size (in some cases by ~25–35%; see [#2095](https://github.com/devantler-tech/ksail/pull/2095) for an example benchmark where Darwin/AMD64 binaries went from 302MB → 217MB, ~28%). Actual size varies by OS/arch, Go version, and dependencies. Development builds include debug symbols for a better debugging experience.

### Test

#### Generating mocks

```sh
# working-directory: ./
mockery
```

#### Unit tests

```sh
# working-directory: ./
go test ./...
```

#### Benchmarks

KSail includes Go benchmarks for performance-critical code paths. When making performance-related changes, run benchmarks to validate improvements:

```sh
# working-directory: ./
# Run all benchmarks
go test -bench=. -benchmem ./...

# Run benchmarks for specific package (e.g., resource polling)
go test -bench=. -benchmem -run=^$ ./pkg/k8s/readiness/...

# Compare before/after performance
go test -bench=. -benchmem -run=^$ ./pkg/k8s/readiness/... > before.txt
# (make changes)
go test -bench=. -benchmem -run=^$ ./pkg/k8s/readiness/... > after.txt
benchstat before.txt after.txt
```

PRs that modify Go code are automatically benchmarked against `main` and the comparison is posted as a PR comment. See [docs/BENCHMARK-REGRESSION.md](docs/BENCHMARK-REGRESSION.md) for details on interpreting results.

See package-specific BENCHMARKS.md files (e.g., `pkg/k8s/readiness/BENCHMARKS.md`, `pkg/client/docker/BENCHMARKS.md`, `pkg/client/flux/BENCHMARKS.md`) for detailed benchmark documentation, baseline results, and performance optimization opportunities.

### Documentation

The project documentation is built using [Astro](https://astro.build/) with the [Starlight](https://starlight.astro.build/) theme and is located in the `docs/` directory.

#### Auto-generated reference docs

Some documentation is generated from source and should **not** be edited manually:

- **CLI flags reference:** `docs/src/content/docs/cli-flags/` (generated by `go generate ./docs/...` from the Cobra command tree)
- **Configuration reference:** `docs/src/content/docs/configuration/declarative-configuration.mdx` (generated by `go generate ./docs/...` from v1alpha1 types)
- **Configuration schema:** `schemas/ksail-config.schema.json` (generated by `go generate ./schemas/...`)

To regenerate locally:

```sh
# working-directory: ./

# Generate reference docs (CLI flags + configuration reference)
go generate ./docs/...

# Generate JSON schema
go generate ./schemas/...
```

#### Building the documentation

```sh
# working-directory: ./docs

# Install dependencies (first time only or when package-lock.json changes)
npm ci

# Build the site
npm run build

# Serve the site locally with live reload (optional)
npm run dev
# Visit http://localhost:4321 to view the site
```

The built site will be available in `docs/dist/`. Note that `docs/dist/` and `docs/node_modules/` are excluded from git via `.gitignore`.

### VSCode Extension

The VSCode extension is located in the `vsce/` directory and provides cluster management capabilities directly in VSCode.

#### Building the extension

```sh
# working-directory: ./vsce

# Install dependencies (first time only or when package-lock.json changes)
npm ci

# Compile TypeScript to JavaScript
npm run compile

# Package as VSIX for distribution
npx @vscode/vsce package --no-dependencies
```

#### Testing locally

1. Open the `vsce` folder in VSCode
2. Press `F5` to launch Extension Development Host
3. Test commands from the Command Palette (`Cmd+Shift+P` / `Ctrl+Shift+P`)

See [vsce/README.md](vsce/README.md) for full extension documentation including features, architecture, and development workflows.

## Project Structure

The repository is organized around the top-level CLI entry point (`main.go`) and the public packages in `pkg/`.

- **main.go** - CLI entry point
- **pkg/cli/cmd/** - CLI command implementations
- **pkg/** - Public packages (importable by external projects)
- **docs/** - Astro documentation site
- **vsce/** - VSCode extension

### Key Packages in pkg/

- **apis/** - API types, schemas, and enums (distribution/provider values)
- **client/** - Embedded tool clients (kubectl, helm, flux, argocd, docker, k9s, kubeconform, kustomize, oci, netretry); distribution tools like kind, k3d, and vcluster are used directly via their SDKs in provisioners, not wrapped in `pkg/client/`
- **client/reconciler/** - Common base for GitOps reconciliation clients (Flux and ArgoCD)
- **svc/detector/** - Detects installed Kubernetes components (Helm releases and Kubernetes API); used by the update command to build accurate baseline cluster state
- **svc/diff/** - Computes configuration differences between ClusterSpec values; classifies update impact (in-place, reboot-required, recreate-required)
- **svc/image/** - Container image export/import services for Vanilla and K3s distributions
- **svc/installer/** - Component installers (CNI, CSI, metrics-server, etc.)
- **svc/provider/** - Infrastructure providers (e.g., `docker.Provider` for running nodes as containers)
- **svc/provisioner/** - Distribution provisioners (Vanilla, K3s, Talos, VCluster)
- **svc/registryresolver/** - OCI registry detection, resolution, and artifact push utilities
- **svc/state/** - Cluster state persistence for distributions that cannot introspect their running configuration (Kind, K3d)
- **di/** - Dependency injection for wiring components

### Architecture: Providers vs Provisioners

KSail separates infrastructure management from distribution configuration:

- **Providers** manage the infrastructure lifecycle (start/stop containers)
- **Provisioners** configure and manage Kubernetes distributions

| Distribution | Provisioner            | Tool  | Provider        | Description                             |
|--------------|------------------------|-------|-----------------|-----------------------------------------|
| `Vanilla`    | KindClusterProvisioner | Kind  | Docker          | Standard upstream Kubernetes            |
| `K3s`        | K3dClusterProvisioner  | K3d   | Docker          | Lightweight K3s in Docker               |
| `Talos`      | TalosProvisioner       | Talos | Docker, Hetzner | Immutable Talos Linux                   |
| `VCluster`   | VClusterProvisioner    | Vind  | Docker          | Virtual clusters via vCluster in Docker |

This project strives to be fully open-source friendly, and as such, all core functionality is implemented in the `pkg/` directory, and the `internal/` directory is not used. This allows external projects to import and use any part of the codebase.

For detailed package and API documentation, refer to [pkg.go.dev/github.com/devantler-tech/ksail/v5](https://pkg.go.dev/github.com/devantler-tech/ksail/v5).

## CI

### GitHub Workflows

#### Unit Tests

```sh
# working-directory: ./
go test ./...
```

#### System Tests

System tests are configured in `.github/workflows/ci.yaml` and run in GitHub’s **merge queue** (the `merge_group` event). They do **not** run on regular `pull_request` checks; instead they gate the final merge to `main` when a PR enters the merge queue.

#### Hetzner Provider Testing

To test the Hetzner provider locally, you need:

- **`HCLOUD_TOKEN`** – Hetzner Cloud API token with read/write permissions
- **Talos ISO** – A Talos Linux ISO must be available in your Hetzner Cloud project. The ISO ID is specific to your project and may change over time; KSail currently assumes a default ID of `122630`, but you should look up the actual ID under **Images → ISOs** in the Hetzner Cloud Console and configure/use that value in your environment.

**Note:** Some unit tests and CLI code paths enable Hetzner functionality when `HCLOUD_TOKEN` is set. If you’re not intentionally testing Hetzner, unset `HCLOUD_TOKEN` (or set it to an empty value) before running `go test ./...` to keep tests hermetic.

**Note:** Hetzner tests incur cloud costs. Use `ksail cluster delete` to clean up resources.

**Note:** CI includes a safety-net cleanup job (`cleanup-hetzner`) that runs after system tests and deletes any Hetzner resources labeled `ksail.owned=true`. This is implemented as a GitHub Action at `.github/actions/cleanup-hetzner/action.yaml` and is not intended for local execution.

**Warning:** The cleanup action is destructive and will delete all KSail-managed Hetzner resources (servers, placement groups, firewalls, and networks) in your project that are labeled `ksail.owned=true`. Manual cleanup of any remaining resources should be done via the Hetzner Cloud Console or `hcloud` CLI if needed.

## CD

### Release Process

The release process for KSail is fully automated and split across two GitHub Actions workflows:

1. **Release** (`.github/workflows/release.yaml`) runs on pushes to `main` and creates the next semantic version tag (`vX.Y.Z`) based on Conventional Commits (typically the PR title / squash-merge commit message).
2. **CD** (`.github/workflows/cd.yaml`) runs on tag pushes (`v*`) and uses **GoReleaser** to build and publish release artifacts.

Versioning conventions:

- **fix:** Patch release (e.g. 1.0.1)
- **feat:** Minor release (e.g. 1.1.0)
- **BREAKING CHANGE** or **`!`**: Major release (e.g. 2.0.0)

The changelog is generated by **GoReleaser** from the commit history, so keep PR titles and commit messages clear and descriptive.

#### Atomic Draft Release Workflow

The CD workflow implements an atomic publication strategy to ensure users never see incomplete releases with missing artifacts:

1. **Draft Creation**: **GoReleaser** creates a **draft release** (configured in `.goreleaser.yaml`) with:
   - Compiled binaries for multiple platforms (Darwin arm64, Linux/Windows on amd64/arm64)
   - Docker images published to GHCR
   - Generated changelog from commit history

2. **VSCode Extension Upload**: A separate job builds the VSCode extension and uploads it as a release asset to the same draft release.

3. **Atomic Publication**: A final `publish-release` job waits for both the `goreleaser` and `vscode-extension` jobs to complete successfully, then publishes the draft release.

This workflow ensures that:

- Releases are only published after **all artifacts** are uploaded
- Users never encounter partial releases with missing binaries or extensions
- If any job fails, the draft remains unpublished and can be deleted or fixed manually
