package docs_test

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/devantler-tech/ksail/v5/pkg/apis/cluster/v1alpha1"
	"github.com/devantler-tech/ksail/v5/pkg/cli/cmd"
	"github.com/spf13/cobra"
)

// countCommands returns the number of non-helper leaf and group-root
// commands in the Cobra tree (matching the shell script's behaviour).
func countCommands(c *cobra.Command) int {
	var subs []*cobra.Command

	for _, sub := range c.Commands() {
		if sub.Name() == "help" || sub.Name() == "completion" {
			continue
		}

		subs = append(subs, sub)
	}

	if len(subs) == 0 {
		return 1 // leaf
	}

	count := 1 // group root page

	for _, sub := range subs {
		count += countCommands(sub)
	}

	return count
}

// skipIfDirMissing skips the test when the directory does not exist.
func skipIfDirMissing(t *testing.T, dir string) {
	t.Helper()

	_, err := os.Stat(dir)
	if os.IsNotExist(err) {
		t.Skipf("docs not generated yet (run go generate ./docs/...): %s", dir)
	}
}

// readOrSkip reads a file's content or skips the test if the file does not exist.
func readOrSkip(t *testing.T, path string) string {
	t.Helper()

	_, err := os.Stat(path)
	if os.IsNotExist(err) {
		t.Skipf("file not generated yet (run go generate ./docs/...): %s", path)
	}

	content, err := os.ReadFile(path) //nolint:gosec // path from test constant, not user input
	if err != nil {
		t.Fatalf("reading %s: %v", path, err)
	}

	return string(content)
}

func TestCLIFlagsDocsExist(t *testing.T) {
	t.Parallel()

	dir := "src/content/docs/cli-flags"
	skipIfDirMissing(t, dir)

	rootCmd := cmd.NewRootCmd("test", "", "")

	// We don't generate a page for the bare "ksail" root, so subtract 1.
	expected := countCommands(rootCmd) - 1

	var actual int

	err := filepath.Walk(dir, func(path string, info os.FileInfo, walkErr error) error {
		if walkErr != nil {
			return walkErr
		}

		isMDX := strings.HasSuffix(path, ".mdx")
		isIndex := strings.HasSuffix(path, "index.mdx")

		if !info.IsDir() && isMDX && !isIndex {
			actual++
		}

		return nil
	})
	if err != nil {
		t.Fatalf("walking %s: %v", dir, err)
	}

	if actual != expected {
		t.Errorf("expected %d CLI flags pages, got %d", expected, actual)
	}
}

// checkFrontmatter validates that a single MDX file contains the expected frontmatter.
func checkFrontmatter(t *testing.T, path string, content []byte) {
	t.Helper()

	text := string(content)

	if !strings.HasPrefix(text, "---\n") {
		t.Errorf("%s: missing frontmatter (should start with ---)", path)
	}

	if !strings.Contains(text, "title:") {
		t.Errorf("%s: missing title in frontmatter", path)
	}

	if !strings.Contains(text, "description:") {
		t.Errorf("%s: missing description in frontmatter", path)
	}
}

func TestCLIFlagsPagesHaveFrontmatter(t *testing.T) {
	t.Parallel()

	dir := "src/content/docs/cli-flags"
	skipIfDirMissing(t, dir)

	err := filepath.Walk(dir, func(path string, info os.FileInfo, walkErr error) error {
		if walkErr != nil {
			return walkErr
		}

		if info.IsDir() || !strings.HasSuffix(path, ".mdx") ||
			strings.HasSuffix(path, "index.mdx") {
			return nil
		}

		content, readErr := os.ReadFile(path) //nolint:gosec // path from filepath.Walk
		if readErr != nil {
			return fmt.Errorf("reading %s: %w", path, readErr)
		}

		checkFrontmatter(t, path, content)

		return nil
	})
	if err != nil {
		t.Fatalf("walking %s: %v", dir, err)
	}
}

func TestIndexMDXPreserved(t *testing.T) {
	t.Parallel()

	text := readOrSkip(t, "src/content/docs/cli-flags/index.mdx")

	if !strings.Contains(text, "title: CLI Flags") {
		t.Error("index.mdx: missing expected title")
	}

	if !strings.Contains(text, "Command Groups") {
		t.Error("index.mdx: missing Command Groups section")
	}
}

func TestConfigReferenceExists(t *testing.T) {
	t.Parallel()

	text := readOrSkip(t, "src/content/docs/configuration/declarative-configuration.mdx")

	t.Run("has frontmatter", func(t *testing.T) {
		t.Parallel()

		if !strings.HasPrefix(text, "---\n") {
			t.Error("missing frontmatter")
		}
	})

	t.Run("has auto-gen tag", func(t *testing.T) {
		t.Parallel()

		if !strings.Contains(text, "auto-generated by go generate") {
			t.Error("missing auto-generation tag")
		}
	})

	t.Run("has configuration reference section", func(t *testing.T) {
		t.Parallel()

		if !strings.Contains(text, "## Configuration Reference") {
			t.Error("missing Configuration Reference section")
		}
	})

	t.Run("has enum values from types", func(t *testing.T) {
		t.Parallel()

		assertEnumValues(t, text)
	})

	t.Run("has environment variable expansion section", func(t *testing.T) {
		t.Parallel()

		if !strings.Contains(text, "Environment Variable Expansion") {
			t.Error("missing Environment Variable Expansion section")
		}
	})

	t.Run("has schema support section", func(t *testing.T) {
		t.Parallel()

		if !strings.Contains(text, "Schema Support") {
			t.Error("missing Schema Support section")
		}
	})
}

// assertEnumValues checks that known enum values appear in the config reference text.
func assertEnumValues(t *testing.T, text string) {
	t.Helper()

	dist := v1alpha1.Distribution("")
	for _, v := range dist.ValidValues() {
		if !strings.Contains(text, "`"+v+"`") {
			t.Errorf("missing distribution value %q", v)
		}
	}

	cni := v1alpha1.CNI("")
	for _, v := range cni.ValidValues() {
		if !strings.Contains(text, "`"+v+"`") {
			t.Errorf("missing CNI value %q", v)
		}
	}
}
