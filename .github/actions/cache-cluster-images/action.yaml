name: Cache Cluster Images
description: |
  Caches container images from a KSail cluster's containerd runtime using
  ksail workload export/import commands. This reduces image pull times
  and avoids flaky pulls in CI.

  The cache key includes a hash of go.mod to automatically invalidate when
  dependency versions change, ensuring cached images stay in sync with the
  codebase.

  Operations:
  - 'restore': Restore cached images and import to cluster (Vanilla/K3s only)
  - 'save': Export images from cluster and save to cache (Vanilla/K3s only)
  - 'list': Output image list for configured components (all distributions)

  Note: Talos clusters do not support export/import operations because the
  Talos Machine API does not expose image export functionality. Use mirror
  registries for Talos image caching instead.

inputs:
  distribution:
    description: |
      Kubernetes distribution (Vanilla, K3s, Talos).
      Talos only supports 'list' operation.
    required: true
  operation:
    description: |
      Cache operation to perform:
      - 'restore': Restore cached images and import to cluster (Vanilla/K3s only)
      - 'save': Export images from cluster and save to cache (Vanilla/K3s only)
      - 'list': Output image list for configured components (all distributions)
    required: true
  cache-version:
    description: |
      Version salt for cache key. Bump this to invalidate all caches.
    required: false
    default: "v1"
  go-mod-hash:
    description: |
      Hash of go.mod file to include in cache key for automatic invalidation
      when dependency versions change. If not provided, cache won't track
      dependency drift.
    required: false
    default: ""
  output-format:
    description: |
      Output format for 'list' operation: 'plain' (one per line) or 'json' (array).
    required: false
    default: "plain"

outputs:
  cache-hit:
    description: Whether the cache was restored successfully
    value: ${{ steps.restore-cache.outputs.cache-hit || 'false' }}
  skipped:
    description: Whether the operation was skipped (e.g., incompatible distribution)
    value: ${{ steps.check-support.outputs.skipped || 'false' }}
  cache-key:
    description: The cache key used for this operation
    value: ${{ steps.check-support.outputs.cache-key || '' }}
  images:
    description: List of images (for 'list' operation)
    value: ${{ steps.list-images.outputs.images || '' }}
  image-count:
    description: Number of images listed (for 'list' operation)
    value: ${{ steps.list-images.outputs.count || '0' }}

runs:
  using: composite
  steps:
    - name: ðŸ” Check distribution support
      id: check-support
      shell: bash
      env:
        DISTRIBUTION: ${{ inputs.distribution }}
        OPERATION: ${{ inputs.operation }}
        CACHE_VERSION: ${{ inputs.cache-version }}
        GO_MOD_HASH: ${{ inputs.go-mod-hash }}
        RUNNER_OS: ${{ runner.os }}
        RUNNER_ARCH: ${{ runner.arch }}
      run: |
        DIST_LOWER=$(echo "$DISTRIBUTION" | tr '[:upper:]' '[:lower:]')

        # 'list' operation works for all distributions
        if [[ "$OPERATION" == "list" ]]; then
          echo "skipped=false" >> "$GITHUB_OUTPUT"
          echo "cache-key=" >> "$GITHUB_OUTPUT"
          exit 0
        fi

        # restore/save operations not supported for Talos
        if [[ "$DIST_LOWER" == "talos" ]]; then
          echo "â­ï¸ Skipping image cache for Talos (export/import not supported by Talos API)"
          echo "â„¹ï¸  Use mirror registries for Talos image caching instead"
          echo "skipped=true" >> "$GITHUB_OUTPUT"
          exit 0
        fi

        echo "skipped=false" >> "$GITHUB_OUTPUT"

        # Generate cache key based on distribution and dependency versions
        # Include go.mod hash to automatically invalidate when dependencies change
        if [[ -n "$GO_MOD_HASH" ]]; then
          # Truncate hash to first 12 characters for readability
          HASH_SHORT="${GO_MOD_HASH:0:12}"
          CACHE_KEY="cluster-images-${CACHE_VERSION}-${DIST_LOWER}-deps-${HASH_SHORT}-${RUNNER_OS}-${RUNNER_ARCH}"
        else
          # Fallback to distribution-only key (less precise, more sharing)
          CACHE_KEY="cluster-images-${CACHE_VERSION}-${DIST_LOWER}-${RUNNER_OS}-${RUNNER_ARCH}"
        fi

        echo "cache-key=$CACHE_KEY" >> "$GITHUB_OUTPUT"
        echo "ðŸ“¦ Cache key: $CACHE_KEY"

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # LIST operation: Output required images for configured components
    # Works for all distributions without requiring a running cluster
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    - name: ðŸ“‹ List required images
      if: inputs.operation == 'list'
      id: list-images
      shell: bash
      env:
        OUTPUT_FORMAT: ${{ inputs.output-format }}
      run: |
        echo "ðŸ“‹ Listing required images for configured components..."

        # Get images using ksail workload images command
        IMAGES=$(ksail workload images --output="$OUTPUT_FORMAT" 2>/dev/null || echo "")

        if [[ -z "$IMAGES" ]]; then
          echo "âš ï¸ No images found for current configuration"
          echo "images=" >> "$GITHUB_OUTPUT"
          echo "count=0" >> "$GITHUB_OUTPUT"
          exit 0
        fi

        # Count images (plain format has one per line)
        if [[ "$OUTPUT_FORMAT" == "plain" ]]; then
          COUNT=$(echo "$IMAGES" | wc -l | tr -d ' ')
        else
          COUNT=$(echo "$IMAGES" | jq -r 'length' 2>/dev/null || echo "unknown")
        fi

        echo "âœ… Found $COUNT required images"
        echo "$IMAGES"

        # Output for GitHub Actions
        # For multiline output, use delimiter
        {
          echo "images<<EOF"
          echo "$IMAGES"
          echo "EOF"
        } >> "$GITHUB_OUTPUT"
        echo "count=$COUNT" >> "$GITHUB_OUTPUT"

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # RESTORE operation: Download cached images and import to cluster
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    - name: ðŸ“¥ Restore image cache
      if: inputs.operation == 'restore' && steps.check-support.outputs.skipped != 'true'
      id: restore-cache
      uses: actions/cache/restore@5a3ec84eff668545956fd18022155c47e93e2684 # v4.2.3
      with:
        path: /tmp/ksail-image-cache
        key: ${{ steps.check-support.outputs.cache-key }}
        restore-keys: |
          cluster-images-${{ inputs.cache-version }}-${{ inputs.distribution }}-deps-
          cluster-images-${{ inputs.cache-version }}-${{ inputs.distribution }}-${{ runner.os }}-

    - name: ðŸ” Validate cache metadata
      if: inputs.operation == 'restore' && steps.check-support.outputs.skipped != 'true' && steps.restore-cache.outputs.cache-hit == 'true'
      id: validate-cache
      shell: bash
      env:
        GO_MOD_HASH: ${{ inputs.go-mod-hash }}
      run: |
        METADATA="/tmp/ksail-image-cache/metadata.json"
        ARCHIVE="/tmp/ksail-image-cache/images.tar"

        # Check if archive exists
        if [[ ! -f "$ARCHIVE" ]]; then
          echo "âš ï¸ Cache archive not found at $ARCHIVE"
          echo "valid=false" >> "$GITHUB_OUTPUT"
          exit 0
        fi

        # Check if metadata exists (older caches might not have it)
        if [[ ! -f "$METADATA" ]]; then
          echo "âš ï¸ Cache metadata not found (older cache format)"
          echo "valid=true" >> "$GITHUB_OUTPUT"  # Still use it, but it's less precise
          exit 0
        fi

        # Validate metadata if go.mod hash is provided
        if [[ -n "$GO_MOD_HASH" ]]; then
          CACHED_HASH=$(jq -r '.go_mod_hash // ""' "$METADATA")
          if [[ "$CACHED_HASH" != "$GO_MOD_HASH" ]]; then
            echo "âš ï¸ Cache dependency mismatch (cached: ${CACHED_HASH:0:12}, current: ${GO_MOD_HASH:0:12})"
            echo "â„¹ï¸  Cache may contain outdated component versions"
            # Still valid, but user is warned
          fi
        fi

        # Display cache metadata
        if command -v jq &> /dev/null; then
          echo "ðŸ“‹ Cache metadata:"
          jq -r '.created_at // "unknown", .tar_entry_count // "unknown", .total_size // "unknown"' "$METADATA" | \
            awk 'NR==1{print "   Created: " $0} NR==2{print "   Entries: " $0} NR==3{print "   Size: " $0}'
        fi

        echo "valid=true" >> "$GITHUB_OUTPUT"

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # SAVE operation: Export images from cluster and save to cache
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    - name: ðŸ“¤ Export images from cluster
      if: inputs.operation == 'save' && steps.check-support.outputs.skipped != 'true'
      id: export-images
      shell: bash
      env:
        GO_MOD_HASH: ${{ inputs.go-mod-hash }}
        DISTRIBUTION: ${{ inputs.distribution }}
        CACHE_VERSION: ${{ inputs.cache-version }}
      run: |
        mkdir -p /tmp/ksail-image-cache
        ARCHIVE="/tmp/ksail-image-cache/images.tar"
        METADATA="/tmp/ksail-image-cache/metadata.json"

        echo "ðŸ“¦ Exporting cluster images to $ARCHIVE"
        ksail workload export "$ARCHIVE" || {
          echo "âš ï¸ Image export failed (non-fatal)"
          echo "export-failed=true" >> "$GITHUB_OUTPUT"
          exit 0
        }

        if [[ ! -f "$ARCHIVE" ]]; then
          echo "âš ï¸ Export completed but archive not found"
          echo "export-failed=true" >> "$GITHUB_OUTPUT"
          exit 0
        fi

        SIZE=$(du -h "$ARCHIVE" | cut -f1)
        SIZE_BYTES=$(stat -c%s "$ARCHIVE" 2>/dev/null || stat -f%z "$ARCHIVE" 2>/dev/null || echo "0")

        echo "âœ… Exported images archive: $SIZE"

        # Generate metadata file to track cache contents and versions
        # This helps validate cache freshness and debug cache issues
        # Note: tar_entry_count includes all entries (directories, manifests, layers), not just image count
        TAR_ENTRY_COUNT=$(tar -tf "$ARCHIVE" 2>/dev/null | wc -l || echo 0)
        CREATED_AT=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

        printf '%s\n' \
          '{' \
          '  "distribution": "'"$DISTRIBUTION"'",' \
          '  "go_mod_hash": "'"${GO_MOD_HASH:-unknown}"'",' \
          '  "created_at": "'"$CREATED_AT"'",' \
          '  "runner_os": "'"$RUNNER_OS"'",' \
          '  "runner_arch": "'"$RUNNER_ARCH"'",' \
          '  "total_size": "'"$SIZE"'",' \
          '  "total_size_bytes": '"$SIZE_BYTES"',' \
          '  "tar_entry_count": "'"$TAR_ENTRY_COUNT"'",' \
          '  "cache_version": "'"$CACHE_VERSION"'"' \
          '}' \
          > "$METADATA"

        echo "ðŸ“‹ Generated cache metadata"
        if command -v jq &> /dev/null; then
          jq '.' "$METADATA"
        else
          cat "$METADATA"
        fi

        echo "export-failed=false" >> "$GITHUB_OUTPUT"

    - name: ðŸ’¾ Save image cache
      if: inputs.operation == 'save' && steps.check-support.outputs.skipped != 'true' && steps.export-images.outputs.export-failed != 'true'
      uses: actions/cache/save@5a3ec84eff668545956fd18022155c47e93e2684 # v4.2.3
      with:
        path: /tmp/ksail-image-cache
        key: ${{ steps.check-support.outputs.cache-key }}
