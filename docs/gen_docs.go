// Copyright (c) KSail contributors. All rights reserved.
// Licensed under the MIT License.

//go:build ignore

// gen_docs.go generates reference documentation from Go source:
//
//   - CLI flags pages under docs/src/content/docs/cli-flags/ (one MDX per command)
//   - Configuration reference at docs/src/content/docs/configuration/declarative-configuration.mdx
//
// It replaces .github/scripts/generate-cli-flags-docs.sh and builds the
// configuration reference directly from v1alpha1 types + prose constants.
//
// Usage:
//
//	go run gen_docs.go
package main

import (
	"fmt"
	"log"
	"os"
	"path/filepath"
	"reflect"
	"regexp"
	"strings"

	"github.com/devantler-tech/ksail/v5/pkg/apis/cluster/v1alpha1"
	"github.com/devantler-tech/ksail/v5/pkg/cli/cmd"
	"github.com/spf13/cobra"
)

const (
	cliDocsDir = "src/content/docs/cli-flags"
	configDoc  = "src/content/docs/configuration/declarative-configuration.mdx"
	autoGenTag = "{/* This page is auto-generated by go generate ./docs/... — DO NOT EDIT */}"

	dirPermissions  = 0o750
	filePermissions = 0o600
)

func main() {
	if err := run(); err != nil {
		log.Fatal(err)
	}
}

func run() error {
	// --- CLI flags ---
	root := cmd.NewRootCmd("dev", "", "")

	if err := generateCLIDocs(root); err != nil {
		return fmt.Errorf("generating CLI docs: %w", err)
	}

	// --- Configuration reference ---
	if err := generateConfigReference(); err != nil {
		return fmt.Errorf("generating config reference: %w", err)
	}

	return nil
}

// ── CLI flags documentation ────────────────────────────────────────────────

// generateCLIDocs recreates the cli-flags directory (preserving index.mdx)
// and walks the Cobra command tree to produce one MDX page per command.
func generateCLIDocs(root *cobra.Command) error {
	// Preserve index.mdx.
	indexPath := filepath.Join(cliDocsDir, "index.mdx")

	var indexBackup []byte

	if data, err := os.ReadFile(indexPath); err == nil {
		indexBackup = data
	}

	// Clean directory.
	if err := os.RemoveAll(cliDocsDir); err != nil {
		return fmt.Errorf("removing %s: %w", cliDocsDir, err)
	}

	if err := os.MkdirAll(cliDocsDir, dirPermissions); err != nil {
		return fmt.Errorf("creating %s: %w", cliDocsDir, err)
	}

	// Restore index.mdx.
	if indexBackup != nil {
		if err := os.WriteFile(indexPath, indexBackup, filePermissions); err != nil {
			return fmt.Errorf("restoring index.mdx: %w", err)
		}
	}

	// Walk command tree.
	var count int

	for _, sub := range root.Commands() {
		if sub.Name() == "help" || sub.Name() == "completion" {
			continue
		}

		n, err := generateCommandDocs(sub, nil)
		if err != nil {
			return err
		}

		count += n
	}

	fmt.Printf("gen_docs: wrote %d CLI flags pages\n", count)

	return nil
}

// generateCommandDocs recursively generates MDX pages for a command.
// parentNames carries the accumulated command path (e.g. ["cluster"]).
func generateCommandDocs(c *cobra.Command, parentNames []string) (int, error) {
	names := append(parentNames, c.Name()) //nolint:gocritic // intentional append to copy

	var subs []*cobra.Command

	for _, sub := range c.Commands() {
		if sub.Name() == "help" || sub.Name() == "completion" {
			continue
		}

		subs = append(subs, sub)
	}

	// Directory for this level is the first name (top-level group).
	groupDir := filepath.Join(cliDocsDir, names[0])
	if err := os.MkdirAll(groupDir, dirPermissions); err != nil {
		return 0, fmt.Errorf("creating %s: %w", groupDir, err)
	}

	// Write root page for this command.
	prefix := strings.Join(names, "-")
	rootFile := filepath.Join(groupDir, prefix+"-root.mdx")
	title := "ksail " + strings.Join(names, " ")
	description := c.Short

	if err := writeCLIPage(rootFile, title, description, c); err != nil {
		return 0, err
	}

	count := 1

	// Recurse into subcommands.
	for _, sub := range subs {
		// Check if this subcommand itself has children.
		var hasChildren bool

		for _, grandchild := range sub.Commands() {
			if grandchild.Name() != "help" && grandchild.Name() != "completion" {
				hasChildren = true
				break
			}
		}

		if hasChildren {
			n, err := generateCommandDocs(sub, names)
			if err != nil {
				return 0, err
			}

			count += n
		} else {
			leafFile := filepath.Join(groupDir, prefix+"-"+sub.Name()+".mdx")
			leafTitle := "ksail " + strings.Join(names, " ") + " " + sub.Name()

			if err := writeCLIPage(leafFile, leafTitle, sub.Short, sub); err != nil {
				return 0, err
			}

			count++
		}
	}

	return count, nil
}

// writeCLIPage writes a single Starlight MDX page for a Cobra command.
func writeCLIPage(path, title, description string, c *cobra.Command) error {
	var b strings.Builder

	b.WriteString("---\n")
	b.WriteString(fmt.Sprintf("title: %q\n", title))
	b.WriteString(fmt.Sprintf("description: %q\n", description))
	b.WriteString("---\n\n")
	b.WriteString(autoGenTag)
	b.WriteString("\n\n```text\n")

	helpText := captureHelp(c)
	b.WriteString(sanitizeHelpText(helpText))
	b.WriteString("\n```\n")

	return os.WriteFile(path, []byte(b.String()), filePermissions)
}

// captureHelp returns the help text for a Cobra command.
func captureHelp(c *cobra.Command) string {
	var buf strings.Builder

	c.SetOut(&buf)
	c.SetErr(&buf)

	// Force help to be generated.
	_ = c.Help()

	return buf.String()
}

// sanitizeHelpText replaces user-specific paths (e.g. /Users/name/...) with ~.
var homePathPattern = regexp.MustCompile(`"/(?:Users|home)/[^/]+/`)

func sanitizeHelpText(text string) string {
	return homePathPattern.ReplaceAllString(text, `"~/`)
}

// ── Configuration reference ────────────────────────────────────────────────

// generateConfigReference builds the declarative-configuration.mdx page from
// prose constants (in gen_docs_prose.go) and reflection on v1alpha1 types.
func generateConfigReference() error {
	var b strings.Builder

	// Frontmatter and intro.
	b.WriteString(configFrontmatter)
	b.WriteString("\n\n")
	b.WriteString(autoGenTag)
	b.WriteString("\n\n")
	b.WriteString(configIntroProse)
	b.WriteString("\n\n")

	// Environment variable expansion section.
	b.WriteString(configEnvVarProse)
	b.WriteString("\n\n")

	// Examples.
	b.WriteString(configMinimalExampleProse)
	b.WriteString("\n\n")
	b.WriteString(configCompleteExampleProse)
	b.WriteString("\n\n")

	// Configuration Reference section — generated from types.
	b.WriteString("## Configuration Reference\n\n")
	generateConfigReferenceTables(&b)

	// Distribution configuration section.
	b.WriteString(configDistributionConfigProse)
	b.WriteString("\n\n")

	// Schema support section.
	b.WriteString(configSchemaProse)
	b.WriteString("\n")

	if err := os.MkdirAll(filepath.Dir(configDoc), dirPermissions); err != nil {
		return fmt.Errorf("creating %s dir: %w", configDoc, err)
	}

	if err := os.WriteFile(configDoc, []byte(b.String()), filePermissions); err != nil {
		return fmt.Errorf("writing %s: %w", configDoc, err)
	}

	fmt.Printf("gen_docs: wrote %s (%d bytes)\n", configDoc, b.Len())

	return nil
}

// generateConfigReferenceTables writes Markdown tables for Cluster, Spec,
// ClusterSpec, WorkloadSpec, ChatSpec and Connection types, plus enum sections.
func generateConfigReferenceTables(b *strings.Builder) {
	// Top-Level Fields.
	b.WriteString("### Top-Level Fields\n\n")
	b.WriteString("| Field | Type | Required | Description |\n")
	b.WriteString("| ----- | ---- | -------- | ----------- |\n")
	b.WriteString("| `apiVersion` | string | Yes | Must be `ksail.io/v1alpha1` |\n")
	b.WriteString("| `kind` | string | Yes | Must be `Cluster` |\n")
	b.WriteString("| `spec` | object | Yes | Cluster and workload specification (see below) |\n\n")

	// spec.
	b.WriteString("### spec\n\n")
	b.WriteString(
		"The `spec` field is a `Spec` object that defines editor, cluster, and workload configuration.\n\n",
	)
	writeFieldTable(b, reflect.TypeOf(v1alpha1.Spec{}), "")

	// spec.editor description.
	b.WriteString("### spec.editor\n\n")
	b.WriteString("Editor command used by KSail for interactive workflows like " +
		"`ksail cipher edit` or `ksail workload edit`.\n\n")
	b.WriteString("**Examples:** `code --wait`, `vim`, `nano`\n\n")
	b.WriteString("If not specified, KSail falls back to standard editor environment variables " +
		"(`SOPS_EDITOR`, `KUBE_EDITOR`, `EDITOR`, `VISUAL`) or system defaults (`vim`, `nano`, `vi`).\n\n")

	// spec.cluster (ClusterSpec).
	b.WriteString("### spec.cluster (ClusterSpec)\n\n")
	writeFieldTable(b, reflect.TypeOf(v1alpha1.ClusterSpec{}), "")

	// Enum detail sections for cluster fields.
	generateEnumSection(
		b,
		"distribution",
		reflect.TypeOf(v1alpha1.Distribution("")),
		distributionDetails,
	)
	generateEnumSection(b, "provider", reflect.TypeOf(v1alpha1.Provider("")), providerDetails)

	b.WriteString(configDistributionProse)
	b.WriteString("\n\n")

	// Connection.
	b.WriteString(configConnectionProse)
	b.WriteString("\n\n")

	generateEnumSection(b, "cni", reflect.TypeOf(v1alpha1.CNI("")), cniDetails)
	generateEnumSection(b, "csi", reflect.TypeOf(v1alpha1.CSI("")), csiDetails)
	generateEnumSection(
		b,
		"metricsServer",
		reflect.TypeOf(v1alpha1.MetricsServer("")),
		metricsServerDetails,
	)
	generateEnumSection(
		b,
		"certManager",
		reflect.TypeOf(v1alpha1.CertManager("")),
		certManagerDetails,
	)
	generateEnumSection(
		b,
		"policyEngine",
		reflect.TypeOf(v1alpha1.PolicyEngine("")),
		policyEngineDetails,
	)

	b.WriteString(configLocalRegistryProse)
	b.WriteString("\n\n")

	generateEnumSection(
		b,
		"gitOpsEngine",
		reflect.TypeOf(v1alpha1.GitOpsEngine("")),
		gitOpsEngineDetails,
	)

	b.WriteString(configDistToolOptions)
	b.WriteString("\n\n")

	// spec.workload (WorkloadSpec).
	b.WriteString("### spec.workload (WorkloadSpec)\n\n")
	writeFieldTable(b, reflect.TypeOf(v1alpha1.WorkloadSpec{}), "")
	b.WriteString("\n")

	// spec.chat (ChatSpec).
	b.WriteString("### spec.chat (ChatSpec)\n\n")
	writeFieldTable(b, reflect.TypeOf(v1alpha1.ChatSpec{}), "")
	b.WriteString("\n")
}

// writeFieldTable writes a Markdown table of struct fields using JSON tags
// and struct tag metadata (default, jsonschema description).
func writeFieldTable(b *strings.Builder, t reflect.Type, prefix string) {
	b.WriteString("| Field | Type | Default | Description |\n")
	b.WriteString("| ----- | ---- | ------- | ----------- |\n")

	for i := range t.NumField() {
		field := t.Field(i)
		if !field.IsExported() {
			continue
		}

		// Skip inline/squash fields (e.g. TypeMeta).
		jsonTag := field.Tag.Get("json")
		if jsonTag == ",inline" || jsonTag == "" {
			continue
		}

		name := strings.Split(jsonTag, ",")[0]
		if name == "-" {
			continue
		}

		fullName := prefix + name
		typeName := friendlyTypeName(field.Type)
		defaultVal := field.Tag.Get("default")
		desc := extractDescription(field)

		if defaultVal == "" {
			defaultVal = "–"
		} else {
			defaultVal = "`" + defaultVal + "`"
		}

		b.WriteString(
			fmt.Sprintf("| `%s` | %s | %s | %s |\n", fullName, typeName, defaultVal, desc),
		)
	}

	b.WriteString("\n")
}

// friendlyTypeName returns a human-readable type name.
func friendlyTypeName(t reflect.Type) string {
	switch t.Kind() {
	case reflect.String:
		// Check if it's an enum type by seeing if pointer implements EnumValuer.
		enumType := reflect.TypeFor[v1alpha1.EnumValuer]()
		if reflect.PointerTo(t).Implements(enumType) {
			return "enum"
		}

		return "string"
	case reflect.Bool:
		return "boolean"
	case reflect.Int32:
		return "int32"
	case reflect.Int64:
		return "int64"
	case reflect.Slice:
		return "[]" + friendlyTypeName(t.Elem())
	case reflect.Struct:
		return t.Name()
	default:
		return t.Name()
	}
}

// extractDescription extracts a description from the jsonschema tag,
// falling back to a cleaned-up version of the field's Go doc comment.
func extractDescription(field reflect.StructField) string {
	tag := field.Tag.Get("jsonschema")
	if tag != "" {
		for _, part := range strings.Split(tag, ",") {
			if strings.HasPrefix(part, "description=") {
				return strings.TrimPrefix(part, "description=")
			}
		}
	}

	return ""
}

// generateEnumSection writes a #### section documenting an enum field
// with its valid values extracted from the EnumValuer interface.
func generateEnumSection(b *strings.Builder, fieldName string, t reflect.Type, details string) {
	b.WriteString(fmt.Sprintf("#### %s\n\n", fieldName))

	// Get valid values via EnumValuer.
	enumValuerType := reflect.TypeFor[v1alpha1.EnumValuer]()
	ptrType := reflect.PointerTo(t)

	if ptrType.Implements(enumValuerType) {
		zero := reflect.New(t)
		values := zero.Interface().(v1alpha1.EnumValuer).ValidValues()

		b.WriteString("**Valid values:**\n\n")

		for _, v := range values {
			b.WriteString(fmt.Sprintf("- `%s`", v))

			// Check if we have a default.
			if hasDefault, ok := zero.Interface().(interface{ Default() any }); ok {
				def := hasDefault.Default()
				if fmt.Sprint(def) == v {
					b.WriteString(" (default)")
				}
			}

			b.WriteString("\n")
		}
	}

	if details != "" {
		b.WriteString("\n")
		b.WriteString(details)
	}

	b.WriteString("\n\n")
}
